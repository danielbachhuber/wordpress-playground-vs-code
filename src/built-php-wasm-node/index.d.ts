// Generated by dts-bundle-generator v7.2.0

export type JavascriptRuntime = "NODE" | "WEB" | "WORKER";
export type PHPRequestHeaders = Record<string, string>;
export interface FileInfo {
	key: string;
	name: string;
	type: string;
	data: Uint8Array;
}
export interface PHPRequest {
	/**
	 * Request path following the domain:port part.
	 */
	relativeUri?: string;
	/**
	 * Path of the .php file to execute.
	 */
	scriptPath?: string;
	/**
	 * Request protocol.
	 */
	protocol?: string;
	/**
	 * Request method. Default: `GET`.
	 */
	method?: "GET" | "POST" | "HEAD" | "OPTIONS" | "PATCH" | "PUT" | "DELETE";
	/**
	 * Request headers.
	 */
	headers?: PHPRequestHeaders;
	/**
	 * Request body without the files.
	 */
	body?: string;
	/**
	 * Uploaded files.
	 */
	fileInfos?: FileInfo[];
	/**
	 * The code snippet to eval instead of a php file.
	 */
	code?: string;
}
export interface PHPResponse {
	/**
	 * The exit code of the script. `0` is a success, while
	 * `1` and `2` indicate an error.
	 */
	exitCode: number;
	/**
	 * Response body. Contains the output from `echo`,
	 * `print`, inline HTML etc.
	 */
	body: ArrayBuffer;
	/**
	 * PHP errors.
	 */
	errors: string;
	/**
	 * Response headers.
	 */
	headers: Record<string, string[]>;
	/**
	 * Response HTTP status code, e.g. 200.
	 */
	httpStatusCode: number;
}
export type PHPRuntimeId = number;
/**
 * Loads the PHP runtime with the given arguments and data dependencies.
 *
 * This function handles the entire PHP initialization pipeline. In particular, it:
 *
 * * Instantiates the Emscripten PHP module
 * * Wires it together with the data dependencies and loads them
 * * Ensures is all happens in a correct order
 * * Waits until the entire loading sequence is finished
 *
 * Basic usage:
 *
 * ```js
 *  const phpLoaderModule = await getPHPLoaderModule("7.4");
 *  const php = await loadPHPRuntime( phpLoaderModule );
 *  console.log(php.run(`<?php echo "Hello, world!"; `));
 *  // { stdout: ArrayBuffer containing the string "Hello, world!", stderr: [''], exitCode: 0 }
 * ```
 *
 * **The PHP loader module:**
 *
 * In the basic usage example, `phpLoaderModule` is **not** a vanilla Emscripten module. Instead,
 * it's an ESM module that wraps the regular Emscripten output and adds some
 * extra functionality. It's generated by the Dockerfile shipped with this repo.
 * Here's the API it provides:
 *
 * ```js
 * // php.wasm size in bytes:
 * export const dependenciesTotalSize = 5644199;
 *
 * // php.wasm filename:
 * export const dependencyFilename = 'php.wasm';
 *
 * // Run Emscripten's generated module:
 * export default function(jsEnv, emscriptenModuleArgs) {}
 * ```
 *
 * **PHP Filesystem:**
 *
 * Once initialized, the PHP has its own filesystem separate from the project
 * files. It's provided by [Emscripten and uses its FS library](https://emscripten.org/docs/api_reference/Filesystem-API.html).
 *
 * The API exposed to you via the PHP class is succinct and abstracts
 * await certain unintuitive parts of low-level FS interactions.
 *
 * Here's how to use it:
 *
 * ```js
 * // Recursively create a /var/www directory
 * php.mkdirTree('/var/www');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // false
 *
 * php.writeFile('/var/www/file.txt', 'Hello from the filesystem!');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // true
 *
 * console.log(php.readFile('/var/www/file.txt'));
 * // "Hello from the filesystem!
 *
 * // Delete the file:
 * php.unlink('/var/www/file.txt');
 * ```
 *
 * For more details consult the PHP class directly.
 *
 * **Data dependencies:**
 *
 * Using existing PHP packages by manually recreating them file-by-file would
 * be quite inconvenient. Fortunately, Emscripten provides a "data dependencies"
 * feature.
 *
 * Data dependencies consist of a `dependency.data` file and a `dependency.js` loader and
 * can be packaged with the [file_packager.py tool]( https://emscripten.org/docs/porting/files/packaging_files.html#packaging-using-the-file-packager-tool).
 * This project requires wrapping the Emscripten-generated `dependency.js` file in an ES
 * module as follows:
 *
 * 1. Prepend `export default function(emscriptenPHPModule) {'; `
 * 2. Prepend `export const dependencyFilename = '<DATA FILE NAME>'; `
 * 3. Prepend `export const dependenciesTotalSize = <DATA FILE SIZE>;`
 * 4. Append `}`
 *
 * Be sure to use the `--export-name="emscriptenPHPModule"` file_packager.py option.
 *
 * You want the final output to look as follows:
 *
 * ```js
 * export const dependenciesTotalSize = 5644199;
 * export const dependencyFilename = 'dependency.data';
 * export default function(emscriptenPHPModule) {
 *    // Emscripten-generated code:
 *    var Module = typeof emscriptenPHPModule !== 'undefined' ? emscriptenPHPModule : {};
 *    // ... the rest of it ...
 * }
 * ```
 *
 * Such a constructions enables loading the `dependency.js` as an ES Module using
 * `import("/dependency.js")`.
 *
 * Once it's ready, you can load PHP and your data dependencies as follows:
 *
 * ```js
 *  const [phpLoaderModule, wordPressLoaderModule] = await Promise.all([
 *    getPHPLoaderModule("7.4"),
 *    import("/wp.js")
 *  ]);
 *  const php = await loadPHPRuntime(phpLoaderModule, {}, [wordPressLoaderModule]);
 * ```
 *
 * @public
 * @param  phpLoaderModule         - The ESM-wrapped Emscripten module. Consult the Dockerfile for the build process.
 * @param  phpModuleArgs           - The Emscripten module arguments, see https://emscripten.org/docs/api_reference/module.html#affecting-execution.
 * @param  dataDependenciesModules - A list of the ESM-wrapped Emscripten data dependency modules.
 * @returns Loaded runtime id.
 */
export declare function loadPHPRuntime(phpLoaderModule: PHPLoaderModule, phpModuleArgs?: EmscriptenOptions, dataDependenciesModules?: DataModule[]): Promise<number>;
export interface WithPHPIniBindings {
	setPhpIniPath(path: string): void;
	setPhpIniEntry(key: string, value: string): void;
}
export interface WithCLI {
	/**
	 * Starts a PHP CLI session with given arguments.
	 *
	 * Can only be used when PHP was compiled with the CLI SAPI.
	 * Cannot be used in conjunction with `run()`.
	 *
	 * @param  argv - The arguments to pass to the CLI.
	 * @returns The exit code of the CLI session.
	 */
	cli(argv: string[]): Promise<number>;
}
export interface WithNodeFilesystem {
	/**
	 * Mounts a Node.js filesystem to a given path in the PHP filesystem.
	 *
	 * @param  settings - The Node.js filesystem settings.
	 * @param  path     - The path to mount the filesystem to.
	 * @see {@link https://emscripten.org/docs/api_reference/Filesystem-API.html#FS.mount}
	 */
	mount(settings: any, path: string): void;
}
export interface WithFilesystem {
	/**
	 * Recursively creates a directory with the given path in the PHP filesystem.
	 * For example, if the path is `/root/php/data`, and `/root` already exists,
	 * it will create the directories `/root/php` and `/root/php/data`.
	 *
	 * @param  path - The directory path to create.
	 */
	mkdirTree(path: string): void;
	/**
	 * Reads a file from the PHP filesystem and returns it as a string.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsText(path: string): string;
	/**
	 * Reads a file from the PHP filesystem and returns it as an array buffer.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsBuffer(path: string): Uint8Array;
	/**
	 * Overwrites data in a file in the PHP filesystem.
	 * Creates a new file if one doesn't exist yet.
	 *
	 * @param  path - The file path to write to.
	 * @param  data - The data to write to the file.
	 */
	writeFile(path: string, data: string | Uint8Array): void;
	/**
	 * Removes a file from the PHP filesystem.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to remove.
	 */
	unlink(path: string): void;
	/**
	 * Lists the files and directories in the given directory.
	 *
	 * @param  path - The directory path to list.
	 * @returns The list of files and directories in the given directory.
	 */
	listFiles(path: string): string[];
	/**
	 * Checks if a directory exists in the PHP filesystem.
	 *
	 * @param  path – The path to check.
	 * @returns True if the path is a directory, false otherwise.
	 */
	isDir(path: string): boolean;
	/**
	 * Checks if a file (or a directory) exists in the PHP filesystem.
	 *
	 * @param  path - The file path to check.
	 * @returns True if the file exists, false otherwise.
	 */
	fileExists(path: string): boolean;
}
export interface WithRun {
	/**
	 * Dispatches a PHP request.
	 * Cannot be used in conjunction with `cli()`.
	 *
	 * @example
	 * ```js
	 * const output = php.run('<?php echo "Hello world!";');
	 * console.log(output.stdout); // "Hello world!"
	 * ```
	 *
	 * @example
	 * ```js
	 * console.log(php.run(`<?php
	 *  $fp = fopen('php://stderr', 'w');
	 *  fwrite($fp, "Hello, world!");
	 * `));
	 * // {"exitCode":0,"stdout":"","stderr":["Hello, world!"]}
	 * ```
	 *
	 * @param  request - PHP Request data.
	 */
	run(request?: PHPRequest): PHPResponse;
}
export type PHPRuntime = any;
export type PHPLoaderModule = {
	dependencyFilename: string;
	dependenciesTotalSize: number;
	default: (jsRuntime: string, options: EmscriptenOptions) => PHPRuntime;
};
export type DataModule = {
	dependencyFilename: string;
	dependenciesTotalSize: number;
	default: (phpRuntime: PHPRuntime) => void;
};
export type EmscriptenOptions = {
	onAbort?: (message: string) => void;
	ENV?: Record<string, string>;
	locateFile?: (path: string) => string;
	noInitialRun?: boolean;
	dataFileDownloads?: Record<string, number>;
	print?: (message: string) => void;
	printErr?: (message: string) => void;
	onRuntimeInitialized?: () => void;
	monitorRunDependencies?: (left: number) => void;
} & Record<string, any>;
export type MountSettings = {
	root: string;
	mountpoint: string;
};
/**
 * An environment-agnostic wrapper around the Emscripten PHP runtime
 * that abstracts the super low-level API and provides a more convenient
 * higher-level API.
 *
 * It exposes a minimal set of methods to run PHP scripts and to
 * interact with the PHP filesystem.
 *
 * @see {startPHP} This class is not meant to be used directly. Use `startPHP` instead.
 */
export declare class PHP implements WithPHPIniBindings, WithFilesystem, WithNodeFilesystem, WithCLI, WithRun {
	#private;
	/**
	 * Initializes a PHP runtime.
	 *
	 * @internal
	 * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
	 */
	constructor(PHPRuntimeId?: PHPRuntimeId);
	initializeRuntime(runtimeId: PHPRuntimeId): void;
	/** @inheritDoc */
	setPhpIniPath(path: string): void;
	/** @inheritDoc */
	setPhpIniEntry(key: string, value: string): void;
	/** @inheritDoc */
	run(request?: PHPRequest): PHPResponse;
	cli(argv: string[]): Promise<number>;
	setSkipShebang(shouldSkip: boolean): void;
	addServerGlobalEntry(key: string, value: string): void;
	mkdirTree(path: string): void;
	readFileAsText(path: string): string;
	/** @inheritDoc */
	readFileAsBuffer(path: string): Uint8Array;
	/** @inheritDoc */
	writeFile(path: string, data: string | Uint8Array): void;
	/** @inheritDoc */
	unlink(path: string): void;
	/** @inheritDoc */
	listFiles(path: string): string[];
	isDir(path: string): boolean;
	fileExists(path: string): boolean;
	mount(settings: MountSettings, path: string): void;
}
/**
 * Output of the PHP.wasm runtime.
 */
export interface PHPOutput {
	/** Exit code of the PHP process. 0 means success, 1 and 2 mean error. */
	exitCode: number;
	/** Stdout data */
	stdout: ArrayBuffer;
	/** Stderr lines */
	stderr: string[];
}
/**
 * Emscripten's filesystem-related Exception.
 *
 * @see https://emscripten.org/docs/api_reference/Filesystem-API.html
 * @see https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/arch/emscripten/bits/errno.h
 */
export type ErrnoError = Error;
export type PHPServerRequest = Pick<PHPRequest, "method" | "headers"> & {
	files?: Record<string, File>;
} & ({
	absoluteUrl: string;
	relativeUrl?: never;
} | {
	absoluteUrl?: never;
	relativeUrl: string;
}) & ((Pick<PHPRequest, "body"> & {
	formData?: never;
}) | {
	body?: never;
	formData: Record<string, unknown>;
});
/**
 * A fake PHP server that handles HTTP requests but does not
 * bind to any port.
 *
 * @public
 * @example
 * ```js
 * import {
 *   loadPHPRuntime,
 *   PHP,
 *   PHPServer,
 *   PHPBrowser,
 *   getPHPLoaderModule,
 * } from '@php-wasm/web';
 *
 * const runtime = await loadPHPRuntime( await getPHPLoaderModule('7.4') );
 * const php = new PHP( runtime );
 *
 * php.mkdirTree('/www');
 * php.writeFile('/www/index.php', '<?php echo "Hi from PHP!"; ');
 *
 * const server = new PHPServer(php, {
 *     // PHP FS path to serve the files from:
 *     documentRoot: '/www',
 *
 *     // Used to populate $_SERVER['SERVER_NAME'] etc.:
 *     absoluteUrl: 'http://127.0.0.1'
 * });
 *
 * const output = server.request({ path: '/index.php' }).body;
 * console.log(new TextDecoder().decode(output));
 * // "Hi from PHP!"
 * ```
 */
export declare class PHPServer {
	#private;
	/**
	 * The PHP instance
	 */
	php: PHP;
	/**
	 * @param  php    - The PHP instance.
	 * @param  config - Server configuration.
	 */
	constructor(php: PHP, config?: PHPServerConfigation);
	/**
	 * Converts a path to an absolute URL based at the PHPServer
	 * root.
	 *
	 * @param  path The server path to convert to an absolute URL.
	 * @returns The absolute URL.
	 */
	pathToInternalUrl(path: string): string;
	/**
	 * Converts an absolute URL based at the PHPServer to a relative path
	 * without the server pathname and scope.
	 *
	 * @param  internalUrl An absolute URL based at the PHPServer root.
	 * @returns The relative path.
	 */
	internalUrlToPath(internalUrl: string): string;
	/**
	 * The absolute URL of this PHPServer instance.
	 */
	get absoluteUrl(): string;
	/**
	 * The absolute URL of this PHPServer instance.
	 */
	get documentRoot(): string;
	/**
	 * Serves the request – either by serving a static file, or by
	 * dispatching it to the PHP runtime.
	 *
	 * @param  request - The request.
	 * @returns The response.
	 */
	request(request: PHPServerRequest): Promise<PHPResponse>;
}
export interface PHPServerConfigation {
	/**
	 * The directory in the PHP filesystem where the server will look
	 * for the files to serve. Default: `/var/www`.
	 */
	documentRoot?: string;
	/**
	 * Server URL. Used to populate $_SERVER details like HTTP_HOST.
	 */
	absoluteUrl?: string;
	/**
	 * Callback used by the PHPServer to decide whether
	 * the requested path refers to a PHP file or a static file.
	 */
	isStaticFilePath?: (path: string) => boolean;
}
export interface WithRequest {
	/**
	 * Sends the request to the server.
	 *
	 * When cookies are present in the response, this method stores
	 * them and sends them with any subsequent requests.
	 *
	 * When a redirection is present in the response, this method
	 * follows it by discarding a response and sending a subsequent
	 * request.
	 *
	 * @param  request   - The request.
	 * @param  redirects - Internal. The number of redirects handled so far.
	 * @returns PHPServer response.
	 */
	request(request: PHPServerRequest, redirects?: number): Promise<PHPResponse>;
}
/**
 * A fake web browser that handles PHPServer's cookies and redirects
 * internally without exposing them to the consumer.
 *
 * @public
 */
export declare class PHPBrowser implements WithRequest {
	#private;
	server: PHPServer;
	/**
	 * @param  server - The PHP server to browse.
	 * @param  config - The browser configuration.
	 */
	constructor(server: PHPServer, config?: PHPBrowserConfiguration);
	request(request: PHPServerRequest, redirects?: number): Promise<PHPResponse>;
}
export interface PHPBrowserConfiguration {
	/**
	 * Should handle redirects internally?
	 */
	handleRedirects?: boolean;
	/**
	 * The maximum number of redirects to follow internally. Once
	 * exceeded, request() will return the redirecting response.
	 */
	maxRedirects?: number;
}
export type WorkerStartupOptions<T extends Record<string, string> = Record<string, string>> = T;
export declare function getPHPLoaderModule(version?: string): Promise<PHPLoaderModule>;
export declare function parseWorkerStartupOptions(): WorkerStartupOptions;

export {};
